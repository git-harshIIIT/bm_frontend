<div class="p-2">
  <div class="inline-block border border-black shadow rounded">
    <div class="px-1 border-b border-black">
      <label>
        <input
          type="checkbox"
          [checked]="table.getIsAllColumnsVisible()"
          (change)="table.getToggleAllColumnsVisibilityHandler()($event)"
        />
        Toggle All
      </label>
    </div>

    @for (column of table.getAllLeafColumns(); track column.id) {
      <div class="px-1">
        <label>
          <input
            type="checkbox"
            [checked]="column.getIsVisible()"
            (change)="column.getToggleVisibilityHandler()($event)"
          />
          {{ column.id }}
        </label>
      </div>
    }
  </div>

  <div class="h-4"></div>

  <div class="flex flex-wrap gap-2">
    <button (click)="rerender()" class="border p-1">Regenerate</button>
    <button (click)="randomizeColumns()" class="border p-1">
      Shuffle Columns
    </button>
  </div>
  <div class="h-4"></div>

  <div class="table-container">
    <table [style.width.px]="table.getTotalSize()">
      <thead>
        @for (headerGroup of table.getHeaderGroups(); track headerGroup.id) {
          <tr>
            @for (header of headerGroup.headers; track header.id) {
              <!-- IMPORTANT: This is where the magic happens! -->
              <th
                [attr.colSpan]="header.colSpan"
                [ngStyle]="getCommonPinningStyles(header.column)"
              >
              @if (header.column.getCanGroup()) {
                <!-- If the header can be grouped, let's add a toggle -->
                <button
                  (click)="header.column.toggleGrouping()"
                  [style.cursor]="'pointer'"
                >
                  @if (header.column.getIsGrouped()) {
                    ðŸ›‘({{ header.column.getGroupedIndex() }})
                  } @else {
                    ðŸ‘Š
                  }
                </button>
              }
                <div class="whitespace-nowrap">
                  @if (!header.isPlaceholder) {
                    <ng-container
                      *flexRender="
                        header.column.columnDef.header;
                        props: header.getContext();
                        let headerValue
                      "
                    >
                      {{ headerValue }}
                    </ng-container>
                  }
                  <!-- Demo getIndex behavior -->
                  <!-- {{
                    header.column.getIndex(
                      header.column.getIsPinned() || 'center'
                    )
                  }} -->
                </div>

                @if (!header.isPlaceholder && header.column.getCanPin()) {
                  <div class="flex gap-1 justify-center">
                    @if (header.column.getIsPinned() !== 'left') {
                      <button
                        class="border rounded px-2"
                        (click)="header.column.pin('left')"
                      >
                        pin left
                      </button>
                    }

                    @if (header.column.getIsPinned()) {
                      <button
                        class="border rounded px-2"
                        (click)="header.column.pin(false)"
                      >
                        unpin
                      </button>
                    }

                    @if (header.column.getIsPinned() !== 'right') {
                      <button
                        class="border rounded px-2"
                        (click)="header.column.pin('right')"
                      >
                        pin right
                      </button>
                    }
                    @if (header.column.getCanFilter()) {
                      <div>
                        <app-table-filter
                          [column]="header.column"
                          [table]="table"
                        />
                      </div>
                    }
                  </div>
                }

                <!-- Resize column -->
                <div
                  class="resizer"
                  [class.isResizing]="header.column.getIsResizing()"
                  (dblclick)="header.column.resetSize()"
                  (mousedown)="header.getResizeHandler()($event)"
                  (touchstart)="header.getResizeHandler()($event)"
                ></div>
              </th>
            }
          </tr>
        }
      </thead>
      <tbody>
        @for (row of table.getRowModel().rows; track row.id) {
          <tr>
            @for (cell of row.getVisibleCells(); track cell.id) {
              <td [style.background]="
              cell.getIsGrouped()
                ? '#0aff0082'
                : cell.getIsAggregated()
                  ? '#ffa50078'
                  : cell.getIsPlaceholder()
                    ? '#ff000042'
                    : 'white'
            " [ngStyle]="getCommonPinningStyles(cell.column)">
            @if (cell.getIsGrouped()) {
              <!-- If it's a grouped cell, add an expander and row count -->
              <button
                (click)="row.toggleExpanded()"
                [style.cursor]="row.getCanExpand() ? 'pointer' : 'normal'"
              >
                {{ row.getIsExpanded() ? 'ðŸ‘‡ ' : 'ðŸ‘‰' }}
              </button>
              <ng-container
                *flexRender="
                  cell.column.columnDef.cell;
                  props: cell.getContext();
                  let cell
                "
              >
                <span>{{ cell }}</span>
              </ng-container>
              {{ ' ' }}{{ row.subRows.length }}
            } @else if (cell.getIsAggregated()) {
              <!-- If the cell is aggregated, use the Aggregated -->
              <!-- renderer for cell -->
              <ng-container
                *flexRender="
                  cell.column.columnDef.aggregatedCell ??
                    cell.column.columnDef.cell;
                  props: cell.getContext();
                  let aggregatedCell
                "
              >
                {{ aggregatedCell }}
              </ng-container>
            } @else if (cell.getIsPlaceholder()) {
              <ng-container />
            } @else {
              <!-- For cells with repeated values, render null-->
              <!-- Otherwise, just render the regular cell-->
              <ng-container
                *flexRender="
                  cell.column.columnDef.cell;
                  props: cell.getContext();
                  let cell
                "
              >
                {{ cell }}
              </ng-container>
            }
                <!-- <ng-container
                  *flexRender="
                    cell.column.columnDef.cell;
                    props: cell.getContext();
                    let cellValue
                  "
                >
                  {{ cellValue }}
                </ng-container> -->
              </td>
            }
          </tr>
        }
      </tbody>
    </table>
    <div class="h-2"></div>
  <div class="flex items-center gap-2">
    <button
      class="border rounded p-1"
      (click)="table.setPageIndex(0)"
      [disabled]="!table.getCanPreviousPage()"
    >
      <<
    </button>
    <button
      class="border rounded p-1"
      (click)="table.previousPage()"
      [disabled]="!table.getCanPreviousPage()"
    >
      <
    </button>
    <button
      class="border rounded p-1"
      (click)="table.nextPage()"
      [disabled]="!table.getCanNextPage()"
    >
      >
    </button>
    <button
      class="border rounded p-1"
      (click)="table.setPageIndex(table.getPageCount() - 1)"
      [disabled]="!table.getCanNextPage()"
    >
      >>
    </button>
    <span class="flex items-center gap-1">
      <div>Page</div>
      <strong>
        {{ table.getState().pagination.pageIndex + 1 }} of
        {{ table.getPageCount() }}
      </strong>
    </span>
    <span class="flex items-center gap-1">
      | Go to page:
      <input
        type="number"
        [value]="table.getState().pagination.pageIndex + 1"
        (input)="onPageInputChange($event)"
        class="border p-1 rounded w-16"
      />
    </span>

    <select
      [value]="table.getState().pagination.pageSize"
      (change)="onPageSizeChange($event)"
    >
      @for (pageSize of [10, 20, 30, 40, 50]; track pageSize) {
        <option [value]="pageSize">Show {{ pageSize }}</option>
      }
    </select>
  </div>
  </div>
</div>

<div class="h-4"></div>
<pre>{{ stringifiedColumnPinning() }}</pre>
